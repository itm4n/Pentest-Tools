import os
import abc
import json
import subprocess
import urllib.request
from enum import Enum
from typing import List

class Check():

    @staticmethod
    def is_root() -> bool:
        return os.geteuid() == 0

    @staticmethod
    def is_connected_to_internet() -> bool:
        try:
            urllib.request.urlopen('https://ifconfig.io', timeout=2)
            return True
        except:
            return False
    
    @staticmethod
    def is_run_with_preserved_env() -> bool:
        return os.getenv('XDG_CURRENT_DESKTOP') != None
    
    @staticmethod
    def is_sudo_non_interactive() -> bool:
        cmd = [ 'sudo', '-n', 'whoami' ]
        try:
            result = subprocess.run(cmd, capture_output=True, check=True)
        except:
            pass
        if result is None or result.returncode != 0 or not 'root' in result.stdout.decode():
            return False
        return True
    
    @staticmethod
    def get_current_user() -> str:
        user = os.getenv('SUDO_USER')
        if user is not None and len(user) != 0:
            return user
        return os.getenv('USER')
    
    @staticmethod
    def get_current_user_home() -> str:
        return os.path.expanduser("~{}".format(Check.get_current_user()))

class PackageType(Enum):
    APT = "apt"
    RUBY = "ruby"
    PYTHON = "python"
    BINARY = "binary"
    GIT = "git"
    GIT_RELEASE = "git_release"

class Component():

    def __init__(self, name: str) -> None:
        self.name = name

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return "'{}'".format(self.name)

    def run(self, args) -> None:
        result = subprocess.run(args, capture_output=True, check=True)
        if result.returncode != 0:
            if len(result.stderr) != 0:
                raise Exception(result.stderr)
            raise Exception(result.stdout)
    
    def execute_custom_script(self, script: str, location: str):
        current_path = os.getcwd()
        current_user = Check.get_current_user()
        current_user_home = Check.get_current_user_home()
        script = script.replace('$USER_NAME', current_user)
        script = script.replace('$USER_HOME', current_user_home)
        os.chdir(location)
        self.run([ 'sudo', '-E', 'bash', '-c', script ])
        os.chdir(current_path)

    @abc.abstractmethod
    def get_type(self) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def install(self) -> None:
        raise NotImplementedError
    
    @abc.abstractmethod
    def update(self) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def remove(self) -> None:
        raise NotImplementedError

class ComponentSystem(Component):

    def __init__(self) -> None:
        super().__init__('system')

    def install(self) -> None:
        self.update()

    def update(self) -> None:
        self.run([ 'sudo', 'apt', 'update' ])
        self.run([ 'sudo', 'apt', 'dist-upgrade', '-o', 'Dpkg::Options::=--force-confold', '-o', 'Dpkg::Options::=--force-confdef', '-qq', '-y', '--allow-downgrades', '--allow-remove-essential', '--allow-change-held-packages' ])

    def remove(self) -> None:
        self.run([ 'sudo', 'apt', 'autoclean', '-y' ])
        self.run([ 'sudo', 'apt', 'autoremove', '-y' ])

class ComponentLocateDb(Component):

    def __init__(self) -> None:
        super().__init__('plocate')

    def install(self) -> None:
        self.update()

    def update(self) -> None:
        self.run([ 'sudo', 'updatedb' ])

class ComponentApt(Component):

    def get_type(self) -> str:
        return 'APT'

    def install(self) -> None:
        self.run([ 'sudo', 'apt', 'install', '-o', 'Dpkg::Options::=--force-confold', '-o', 'Dpkg::Options::=--force-confdef', '-qq', '--allow-change-held-packages', '-y', self.name ])

    def update(self) -> None:
        # There is no need for an update command here as it is already handled by
        # 'apt upgrade'. However, we can check whether the package is installed
        # and install it if needed.
        try:
            # Run 'dpkg' to check whether the package is installed. If it is not
            # installed, the command returns the error code 1, which will raise
            # an exception in 'self.run()'.
            self.run(['dpkg', '-l', self.name])
        except:
            # Catch any exception raised by 'self.run()'. If we are here, it probably
            # means that the package is not installed. So, call 'self.install()' to
            # install it.
            self.install()
    
    def remove(self) -> None:
        self.run([ 'sudo', 'apt', 'autoremove', '-o', 'Dpkg::Options::=--force-confold', '-o', 'Dpkg::Options::=--force-confdef', '-qq', '--allow-change-held-packages', '-y', self.name ])

class ComponentPython(Component):

    def get_type(self) -> str:
        return 'Python'

    def install(self) -> None:
        self.run([ 'pipx', 'install', self.name ])
    
    def update(self) -> None:
        try:
            # First determine whether the package installed with the command 
            # 'pipx list'. If it is not the case, 'grep' returns the code '1',
            # which is interpreted as an error by 'self.run()' and causes it
            # to raise an exception.
            self.run(['bash', '-c', "pipx list --short | grep '{}'".format(self.name)])
            # If no exception is raised by the previous 'self.run()', it means
            # that the package exists so we can try to upgrade it.
            self.run([ 'pipx', 'upgrade', self.name ])
        except:
            # Catch any exception raised by 'self.run()'. It we are here, it probably
            # means that the package is not installed. So, call 'self.install()' to 
            # install it.
            self.install()
    
    def remove(self) -> None:
        self.run([ 'pipx', 'uninstall', self.name ])

class ComponentRuby(Component):

    def get_type(self) -> str:
        return 'Ruby'

    def install(self) -> None:
        self.run([ 'sudo', 'gem', 'install', self.name ])

    def update(self) -> None:
        self.run([ 'sudo', 'gem', 'update', self.name ])
    
    def remove(self) -> None:
        self.run([ 'sudo', 'gem', 'uninstall', self.name ])

class ComponentBinary(Component):

    def __init__(self, name: str, url: str, category: str, script: str, root_dir: str) -> None:
        super().__init__(name)
        self.url = url
        self.category = category
        self.script = script
        self.root_dir = root_dir

    def get_type(self) -> str:
        return 'binary'
    
    def __get_install_path(self) -> str:
        return os.path.join(self.root_dir, self.category, "{}-bin".format(self.name))

    def install(self) -> None:
        install_path = self.__get_install_path()
        if not os.path.exists(install_path):
            os.makedirs(install_path, exist_ok=True)
        self.run([ 'sudo', 'wget', self.url, '--quiet', '-O', os.path.join(install_path, self.url.rsplit('/', 1)[-1]) ])
        if self.script is not None:
            self.execute_custom_script(self.script, self.__get_install_path())
    
    def update(self) -> None:
        self.install()
    
    def remove(self) -> None:
        install_path = self.__get_install_path()
        if os.path.exists(install_path):
            self.run([ 'sudo', 'rm', '-rf', install_path ])

class ComponentGit(Component):

    def __init__(self, name: str, user: str, category: str, script: str, root_dir: str) -> None:
        super().__init__(name)
        self.user = user
        self.category = category
        self.script = script
        self.root_dir = root_dir

    def __str__(self) -> str:
        return "{}/{}".format(self.user, self.name)

    def get_type(self) -> str:
        return 'git'

    def __get_install_path(self) -> str:
        return os.path.join(self.root_dir, self.category)

    def __get_repository_path(self) -> str:
        return os.path.join(self.__get_install_path(), self.name)
    
    def __get_repository_url(self) -> str:
        return "https://github.com/{}/{}".format(self.user, self.name)
    
    def __install_or_update(self) -> None:
        current_path = os.getcwd()
        install_path = self.__get_install_path()
        if not os.path.exists(install_path):
            os.makedirs(install_path, exist_ok=True)
        git_path = self.__get_repository_path()
        if not os.path.exists(git_path):
            os.chdir(install_path)
            self.run([ 'sudo', 'git', 'clone', self.__get_repository_url(), '--depth', '1'])
            os.chdir(current_path)
        else:
            os.chdir(git_path)
            self.run([ 'sudo', 'git', 'pull', '--no-rebase'])
            os.chdir(current_path)
        if self.script is not None:
            self.execute_custom_script(self.script, self.__get_repository_path())

    def install(self) -> None:
        self.__install_or_update()
    
    def update(self) -> None:
        self.__install_or_update()
    
    def remove(self) -> None:
        git_path = self.__get_repository_path()
        if os.path.exists(git_path):
            self.run([ 'sudo', 'rm', '-rf', git_path ])

class ComponentGitRelease(Component):

    def __init__(self, name: str, user: str, category: str, password: str, root_dir: str) -> None:
        super().__init__(name)
        self.user = user
        self.category = category
        self.password = password
        self.root_dir = root_dir

    def __str__(self) -> str:
        return "{}/{}".format(self.user, self.name)

    def get_type(self) -> str:
        return 'git release'

    def __get_install_path(self) -> str:
        return os.path.join(self.root_dir, self.category)

    def __get_repository_path(self) -> str:
        return os.path.join(self.__get_install_path(), "{}-bin".format(self.name))

    def __get_git_release_information(self) -> any:
        release_url = "https://api.github.com/repos/{}/{}/releases/latest".format(self.user, self.name)
        request = urllib.request.Request(release_url, data=None, headers={ 'User-Agent': 'curl/7.86.0' })
        response = urllib.request.urlopen(request)
        response_text = response.read().decode('utf-8')
        if response.status != 200:
            raise Exception(response_text)
        return json.loads(response_text)

    def __install_or_update(self) -> None:
        # Check whether the destination directory exists. Create it if it does
        # not exist.
        local_path = self.__get_repository_path()
        if not os.path.exists(local_path):
            os.makedirs(local_path, exist_ok=True)
        # Retrieve metadata about the GitHub release.
        release_info = self.__get_git_release_information()
        # If the archive is password-protected but the password is not known,
        # try to extract it from the release description.
        if self.password == 'UNKNOWN':
            for w in release_info['body'].split():
                if len(w) >= 20:
                    self.password = w
                    break
        # Get the current local version. Ne need to download everything if we 
        # already have the latest release.
        version_file_path = os.path.join(local_path, '.version')
        if os.path.exists(version_file_path):
            f = open(version_file_path)
            version = f.read()
            f.close()
            if version == release_info['tag_name']:
                return
        # Download each asset.
        current_path = os.getcwd()
        os.chdir(local_path)
        for a in release_info['assets']:
            is_archive = True
            self.run([ 'sudo', 'wget', '--quiet', a['browser_download_url'] ])
            filename_full = a['browser_download_url'].rsplit('/', 1)[-1]
            filename = filename_full.rsplit('.', 1)[0]
            fileext = filename_full.rsplit('.', 1)[-1]
            if fileext == 'zip':
                self.run([ 'sudo', 'unzip', '-o', filename_full, '-d', filename ])
            elif fileext == 'gz':
                self.run([ 'sudo', 'gzip', '-f', '-d', filename_full ])
            elif fileext == '7z':
                if self.password:
                    self.run([ 'sudo', '7z', 'x', '-aou', "-p{}".format(self.password), filename_full])
                else:
                    self.run([ 'sudo', '7z', 'x', '-aou', filename_full])
            else:
                is_archive = False
            if is_archive:
                self.run([ 'sudo', 'rm', '-rf', filename_full ])
        os.chdir(current_path)
        # Write the version file.
        self.run([ 'sudo', 'bash', '-c', "echo -n '{}' > {}".format(release_info['tag_name'], version_file_path) ])
        # f = open(version_file_path, 'w')
        # f.write(release_info['tag_name'])
        # f.close()

    def install(self) -> None:
        return self.__install_or_update()

    def update(self) -> None:
        return self.__install_or_update()

class ComponentSymlink(Component):

    def __init__(self, name: str, target: str, link: str, category: str, root_dir: str) -> None:
        super().__init__(name)
        self.link = link
        self.category = category
        self.root_dir = root_dir
        self.target = ""
        if self.category is None:
            self.target = target
        else:
            self.target = os.path.join(self.root_dir, self.category, target)
    
    def install(self) -> None:
        self.run([ 'sudo', 'ln', '-f', '-s', self.target, self.link ])

    def remove(self) -> None:
        self.run([ 'sudo', 'rm', '-f', self.link ])

class ComponentAlias(Component):

    def __init__(self, name: str, command: str, category: str, root_dir: str, alias_file: str) -> None:
        super().__init__(name)
        self.command = command
        self.category = category
        self.root_dir = root_dir
        self.alias_file = alias_file
    
    def __install_or_update(self) -> None:
        if self.category is not None:
            self.command = "{}/{}/{}".format(self.root_dir, self.category, self.command)
        alias_line = "alias {}=\"{}\"\n".format(self.name, self.command)
        with open(self.alias_file, 'a') as f:
            f.write(alias_line)
    
    def install(self) -> None:
        self.__install_or_update()
    
    def upddate(self) -> None:
        self.__install_or_update()

    def initialize_alias_file(self) -> bool:
        with open(self.alias_file, 'w') as f:
            f.write('')
        # self.run([ 'chown', "{}:".format(Check.get_current_user()), self.alias_file])
        return True

class ComponentTerminatorConfig(Component):

    def __init__(self) -> None:
        super().__init__('config_terminator')

    def install(self) -> None:
        config_filepath = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'config_terminator.txt')
        target_dirpath = os.path.join(Check.get_current_user_home(), '.config', 'terminator')
        target_filepath = os.path.join(target_dirpath, 'config')
        config = ""
        os.makedirs(target_dirpath, exist_ok=True)
        with open(config_filepath) as f:
            config = f.read()
        if len(config) == 0:
            raise Exception('The configuration is empty.')
        with open(target_filepath, 'w') as f:
            f.write(config)
        # self.run([ 'chown', '-R', "{}:".format(Check.get_current_user()), target_dirpath ])

class ComponentMetasploitConfig(Component):

    def __init__(self) -> None:
        super().__init__('config_metasploit')
    
    def install(self) -> None:
        self.run([ 'sudo', 'systemctl', 'start', 'postgresql' ])
        self.run([ 'sudo', 'systemctl', 'enable', '--now', 'postgresql' ])
        self.run([ 'sudo', 'msfdb', 'init' ])

class ComponentXfceConfig(Component):

    def __init__(self) -> None:
        super().__init__('config_xfce')
    
    def install(self) -> None:
        self.run([ 'sudo', 'xfconf-query', '-c', 'xfce4-power-manager', '-p', '/xfce4-power-manager/blank-on-ac', '-s', '0' ])
        self.run([ 'sudo', 'xfconf-query', '-c', 'xfce4-power-manager', '-p', '/xfce4-power-manager/dpms-on-ac-sleep', '-s', '0' ])
        self.run([ 'sudo', 'xfconf-query', '-c', 'xfce4-power-manager', '-p', '/xfce4-power-manager/dpms-on-ac-off', '-s', '0' ])
        self.run([ 'sudo', 'xfconf-query', '-c', 'xfce4-desktop', '-p', '/backdrop/screen0/monitorVirtual1/workspace0/last-image', '-s', '/usr/share/backgrounds/kali/kali-small-logo.png' ])
        self.run([ 'sudo', 'xfconf-query', '-c', 'xfce4-panel', '-p', '/panels/panel-1/size', '-s', '36' ])
        self.run([ 'sudo', 'xfconf-query', '-c', 'xfce4-panel', '-p', '/plugins/plugin-12/show-labels', '-s', 'false' ])

class ComponentGnomeConfig(Component):

    def __init__(self) -> None:
        super().__init__('config_gnome')

    def install(self) -> None:
        # Configure tab navigation shortcuts in Gnome Terminal
        self.run([ 'sudo', 'gsettings', 'set', 'org.gnome.Terminal.Legacy.Keybindings:/org/gnome/terminal/legacy/keybindings/', 'next-tab', '<Primary>Tab' ])
        self.run([ 'sudo', 'gsettings', 'set', 'org.gnome.Terminal.Legacy.Keybindings:/org/gnome/terminal/legacy/keybindings/', 'prev-tab', '<Primary><Shift>Tab' ])
        # Disable auto-suspend and black screen
        self.run([ 'sudo', 'gsettings', 'set', 'org.gnome.settings-daemon.plugins.power', 'sleep-inactive-ac-type', 'nothing' ])
        self.run([ 'sudo', 'gsettings', 'set', 'org.gnome.desktop.session', 'idle-delay', '0' ])

class ComponentSambaConfig(Component):

    def __init__(self, pub_dir: str) -> None:
        super().__init__('config_samba')
        self.pub_dir = pub_dir
    
    def install(self) -> None:
        dir_pub_loot = os.path.join(self.pub_dir, 'loot')
        dir_pub_tools = os.path.join(self.pub_dir, 'tools')
        dir_pub_temp = os.path.join(self.pub_dir, 'temp')
        filepath_smb_config = '/etc/samba/smb.conf'
        filepath_smb_config_bak = "{}.bak".format(filepath_smb_config)
        html = '<html><body bgcolor="#000000"><h1><center><font color="#cc0000">WhAt ArE yOu DoInG tHeRe???</font></center></h1></body></html>'
        # Create the directory structure
        self.run([ 'sudo', 'mv', filepath_smb_config, filepath_smb_config_bak ])
        self.run([ 'sudo', 'adduser', '--system', 'shareuser' ])
        self.run([ 'sudo', 'mkdir', '-p', dir_pub_loot, dir_pub_tools, dir_pub_temp ])
        self.run([ 'sudo', 'chmod', 'ugo=rwx', self.pub_dir ])
        self.run([ 'sudo', 'chmod', 'u=rwx,go=wx', dir_pub_loot ])
        self.run([ 'sudo', 'chmod', 'u=rwx,go=rx', dir_pub_tools ])
        self.run([ 'sudo', 'chmod', 'ugo=rwx', dir_pub_temp ])
        # Create the Samba config file
        filepath_smb_config_new = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'config_samba.txt')
        with open(filepath_smb_config_new) as fr:
            config_smb = fr.read()
            with open(filepath_smb_config, 'w') as fw:
                fw.write(config_smb)
        # Create an index.html file in each directory
        with open(os.path.join(dir_pub_tools, 'index.html'), 'w') as f:
            f.write(html)
        with open(os.path.join(dir_pub_loot, 'index.html'), 'w') as f:
            f.write(html)
        with open(os.path.join(dir_pub_temp, 'index.html'), 'w') as f:
            f.write(html)
        # Restart the samba service to load the new configuration, and stop it.
        self.run([ 'sudo', 'systemctl', 'restart', 'smbd' ])
        self.run([ 'sudo', 'systemctl', 'stop', 'smbd' ])

class Config():

    def __init__(self, filepath: str) -> None:
        self.filepath = filepath
        self.current_filepath = "{}/.pwnbox-config.json".format(os.path.expanduser('~'))
        self.config = None
        self.current_config = None

    def __get_config(self, current=False) -> any:
        if current:
            return self.current_config
        else:
            return self.config
    
    def initialize_config(self, current=False) -> None:
        if current:
            with open(self.current_filepath) as f:
                self.current_config = json.load(f)
        else:
            with open(self.filepath) as f:
                self.config = json.load(f)
    
    def get_package_list(self, type: PackageType, current=False) -> List[Component]:
        res = []
        config = self.__get_config(current=current)
        if config is None:
            return
        for p in config['package'][type.value]:
            if type == PackageType.APT:
                res.append(ComponentApt(p))
            elif type == PackageType.PYTHON:
                res.append(ComponentPython(p))
            elif type == PackageType.RUBY:
                res.append(ComponentRuby(p))
            elif type == PackageType.BINARY:
                res.append(ComponentBinary(p['name'], p['url'], p['category'], p['script'], self.config['global']['dir_tools']))
            elif type == PackageType.GIT:
                res.append(ComponentGit(p['name'], p['user'], p['category'], p['script'], self.config['global']['dir_tools']))
            elif type == PackageType.GIT_RELEASE:
                res.append(ComponentGitRelease(p['name'], p['user'], p['category'], p['archive_password'], self.config['global']['dir_tools']))
        return res
    
    def get_symlink_list(self, current=False) -> List[ComponentSymlink]:
        res = []
        config = self.__get_config(current=current)
        if config is None:
            return None
        for s in config['environment']['symlink']:
            link = ComponentSymlink(name=s['name'], target=s['target'], link=s['link'], category=s['category'], root_dir=self.config['global']['dir_tools'])
            res.append(link)
        return res

    def get_alias_list(self, current=False) -> List[ComponentAlias]:
        res = []
        config = self.__get_config(current=current)
        if config is None:
            return None
        for a in config['environment']['alias']:
            alias = ComponentAlias(name=a['name'], command=a['command'], category=a['category'], root_dir=config['global']['dir_tools'], alias_file=None)
            res.append(alias)
        return res
