import sys
from enum import Enum
from log import *
from helper import *

class ControllerAction(Enum):
    INSTALL = 1
    UPDATE = 2
    REMOVE = 3

class Controller():

    def __init__(self, config_file: str):
        try:
            self.config = Config(filepath=config_file)
            self.config.initialize_config()
            Logger.success("Loaded config file '{}'.".format(self.config.filepath))
        except:
            Logger.error("Failed to load config file '{}'.".format(self.config.filepath))
        try:
            self.config.initialize_config(current=True)
            Logger.success("Loaded config file '{}'.".format(self.config.current_filepath))
        except:
            Logger.warning("Failed to load config file '{}'.".format(self.config.current_filepath))
    
    def __get_action_fail_msg(self, action: ControllerAction) -> str:
        if action == ControllerAction.INSTALL:
            return "Failed to install package"
        elif action == ControllerAction.UPDATE:
            return "Failed to update package"
        elif action == ControllerAction.REMOVE:
            return "Failed to remove package"
    
    def __get_action_success_msg(self, action: ControllerAction) -> str:
        if action == ControllerAction.INSTALL:
            return "Installed"
        elif action == ControllerAction.UPDATE:
            return "Updated"
        elif action == ControllerAction.REMOVE:
            return "Removed"

    def __get_action_msg(self, action: ControllerAction) -> str:
        if action == ControllerAction.INSTALL:
            return "Installing"
        elif action == ControllerAction.UPDATE:
            return "Updating"
        elif action == ControllerAction.REMOVE:
            return "Removing"

    def __run_with_progress(self, packages: List[Component], action: ControllerAction) -> None:
        cnt = 0
        cnt_ok = 0
        previous_len = 0
        package_type = ""
        for p in packages:
            package_type = p.get_type()
            flag_success = False
            previous_len = Logger.show_progress(cnt + 1, len(packages))
            msg = " {} {} package: {}".format(self.__get_action_msg(action), p.get_type(), p)
            sys.stdout.write(msg)
            sys.stdout.flush()
            try:
                if action == ControllerAction.INSTALL:
                    p.install()
                elif action == ControllerAction.UPDATE:
                    p.update()
                elif action == ControllerAction.REMOVE:
                    p.remove()
                flag_success = True
                cnt_ok += 1
            except subprocess.CalledProcessError as error:
                sys.stdout.write('\n')
                Logger.error("The following command failed (exit code: {}): {}".format(error.returncode, " ".join(error.cmd)))
                for l in error.stderr.decode('utf-8').split('\n'):
                    if (len(l) > 0):
                        Logger.info("STDERR: {}".format(l))
            except Exception as e:
                sys.stdout.write('\n')
                Logger.error("Unknown error: {}".format(e))
            finally:
                if not flag_success:
                    Logger.warning("{} '{}'".format(self.__get_action_fail_msg(action), p))
            previous_len += len(msg)
            cnt += 1
            Logger.reset_line(pad=previous_len)
        if cnt_ok != 0:
            msg = "{} {}/{} {} package(s).".format(self.__get_action_success_msg(action), cnt_ok, len(packages), package_type)
            Logger.success(msg)

    def __save_config_file_as_current(self) -> None:
        try:
            new_config = ""
            with open(self.config.filepath) as f:
                new_config = f.read()
            if len(new_config) > 0:
                with open(self.config.current_filepath, 'w') as f:
                    f.write(new_config)
        except Exception as e:
            Logger.error("Unknown error: {}".format(e))

    def __update_system(self) -> None:
        msg = 'Updating system...'
        Logger.info(msg, new_line=False)
        system = ComponentSystem()
        system.update()
        Logger.reset_line(pad=len(msg))
        Logger.success("The system was updated.")

    def __cleanup_system(self) -> None:
        msg = 'Cleaning up system...'
        Logger.info(msg, new_line=False)
        system = ComponentSystem()
        system.remove()
        Logger.reset_line(pad=len(msg))
        Logger.success("The system was cleaned up.")

    def __update_locate_db(self) -> None:
        msg = 'Updating locate database...'
        Logger.info(msg, new_line=False)
        locate = ComponentLocateDb()
        locate.update()
        Logger.reset_line(pad=len(msg))
        Logger.success("The locate database was updated.")

    def __update_all_packages(self, type: PackageType) -> None:
        self.__run_with_progress(self.config.get_package_list(type), ControllerAction.UPDATE)

    def __install_all_packages(self, type: PackageType) -> None:
        self.__run_with_progress(self.config.get_package_list(type), ControllerAction.INSTALL)

    def __remove_all_deleted_packages(self, type: PackageType) -> None:
        new_list = self.config.get_package_list(type)
        old_list = self.config.get_package_list(type, current=True)
        if old_list is None:
            return
        to_remove = []
        # For each package in the current configuration, check whether it is
        # still present in the new configuration. If not, add the package to
        # a temporary list.
        for o in old_list:
            found = False
            for n in new_list:
                if o.name == n.name:
                    found = True
                    break
            if not found:
                to_remove.append(o)
        # Remove all the packages that were added to the temporary list.
        self.__run_with_progress(to_remove, ControllerAction.REMOVE)

    def __remove_all(self):
        self.__remove_all_deleted_packages(PackageType.APT)
        self.__remove_all_deleted_packages(PackageType.PYTHON)
        self.__remove_all_deleted_packages(PackageType.RUBY)
        self.__remove_all_deleted_packages(PackageType.BINARY)
        self.__remove_all_deleted_packages(PackageType.GIT)
        self.__remove_all_deleted_packages(PackageType.GIT_RELEASE)
    
    def __configure_symlinks(self):
        msg = 'Configuring symlink(s)...'
        Logger.info(msg, new_line=False)
        cnt = 0
        cnt_remove = 0
        new_list = self.config.get_symlink_list()
        old_list = self.config.get_symlink_list(current=True)
        # List currently configured symlinks that would no longer be present in
        # the newer configuration file, and remove them.
        if old_list is not None:
            for o in old_list:
                found = False
                for n in new_list:
                    if o.name == n.name:
                        found = True
                        break
                if not found:
                    o.remove()
                    cnt_remove += 1
        if cnt_remove != 0:
            Logger.reset_line(pad=len(msg))
            Logger.info("Removed {} symlink(s).".format(cnt_remove))
        for n in new_list:
            try:
                n.install()
                cnt += 1
            except subprocess.CalledProcessError as error:
                Logger.reset_line(pad=len(msg))
                Logger.error("The following command failed (exit code: {}): {}".format(error.returncode, " ".join(error.cmd)))
                for l in error.stderr.decode('utf-8').split('\n'):
                    if (len(l) > 0):
                        Logger.info("STDERR: {}".format(l))
            except Exception as e:
                Logger.reset_line(pad=len(msg))
                Logger.error("Failed to configure symlink '{}': {}.".format(n.name, e))
        Logger.reset_line(pad=len(msg))
        Logger.success("Configured {} symlink(s).".format(cnt))
    
    def __configure_aliases(self) -> None:
        msg = 'Configuring alias(es)...'
        Logger.info(msg, new_line=False)
        # First ensure that the .zshrc file sources the .bash_aliases file.
        source_alias_found = False
        zshrc_file = os.path.join(Check.get_current_user_home(), '.zshrc')
        with open(zshrc_file) as f:
            for l in f.readlines():
                if '. ~/.bash_aliases' in l:
                    source_alias_found = True
                    break
        if not source_alias_found:
            with open(zshrc_file, 'a') as f:
                text = "\n\n# Alias definitions.\n# You may want to put all your additions into a separate file like\n# ~/.bash_aliases, instead of adding them here directly.\n# See /usr/share/doc/bash-doc/examples in the bash-doc package.\n\nif [ -f ~/.bash_aliases ]; then\n    . ~/.bash_aliases\nfi\n"
                f.write(text)
        # Get the alias list from the config file, empty the alias file and
        # populate it with the new aliases.
        cnt = 0
        alias_file = os.path.join(Check.get_current_user_home(), '.bash_aliases')
        alias_list = self.config.get_alias_list()
        alias_file_initialized = False
        for a in alias_list:
            a.alias_file = alias_file
            if not alias_file_initialized:
                alias_file_initialized = a.initialize_alias_file()
            try:
                a.install()
                cnt += 1
            except subprocess.CalledProcessError as error:
                Logger.reset_line(pad=len(msg))
                Logger.error("The following command failed (exit code: {}): {}".format(error.returncode, " ".join(error.cmd)))
                for l in error.stderr.decode('utf-8').split('\n'):
                    if (len(l) > 0):
                        Logger.info("STDERR: {}".format(l))
            except Exception as e:
                Logger.reset_line(pad=len(msg))
                Logger.error("Failed to configure alias '{}': {}.".format(a.name, e))
        Logger.reset_line(pad=len(msg))
        Logger.success("Configured {} alias(es).".format(cnt))

    def __configure_terminator(self):
        msg = 'Configuring Terminator...'
        Logger.info(msg, new_line=False)
        c = ComponentTerminatorConfig()
        try:
            c.install()
            Logger.reset_line(pad=len(msg))
            Logger.success("Configured Terminator terminal.")
        except Exception as e:
            Logger.reset_line(pad=len(msg))
            Logger.error("Failed to configure Terminator: {}".format(e))

    def __configure_vim(self):
        msg = 'Configuring VIM...'
        Logger.info(msg, new_line=False)
        c = ComponentVimConfig()
        try:
            c.install()
            Logger.reset_line(pad=len(msg))
            Logger.success("Configured VIM.")
        except Exception as e:
            Logger.reset_line(pad=len(msg))
            Logger.error("Failed to configure VIM: {}".format(e))

    def __configure_metasploit(self):
        msg = 'Configuring Metasploit...'
        Logger.info(msg, new_line=False)
        c = ComponentMetasploitConfig()
        try:
            c.install()
            Logger.reset_line(pad=len(msg))
            Logger.success("Configured and initialized Metasploit.")
        except subprocess.CalledProcessError as error:
            Logger.reset_line(pad=len(msg))
            Logger.error("The following command failed (exit code: {}): {}".format(error.returncode, " ".join(error.cmd)))
            for l in error.stderr.decode('utf-8').split('\n'):
                if (len(l) > 0):
                    Logger.info("STDERR: {}".format(l))
        except Exception as e:
            Logger.reset_line(pad=len(msg))
            Logger.error("Failed to configure Metasploit: '{}'.".format(e))
    
    def __configure_desktop_environment(self):
        de = os.getenv('XDG_CURRENT_DESKTOP').lower()
        config = None
        if de == 'xfce':
            config = ComponentXfceConfig()
        elif de == 'gnome':
            config = ComponentGnomeConfig()
        if config is not None:
            msg = 'Configuring Desktop Environment...'
            Logger.info(msg, new_line=False)
            config.install()
            Logger.reset_line(pad=len(msg))
            Logger.success("Configured Desktop Environment.")
    
    def __configure_samba(self):
        msg = 'Configuring Samba server...'
        Logger.info(msg, new_line=False)
        c = ComponentSambaConfig(pub_dir=self.config.config['global']['dir_pub'])
        try:
            c.install()
            Logger.reset_line(pad=len(msg))
            Logger.success("Configured samba service.")
        except subprocess.CalledProcessError as error:
            Logger.reset_line(pad=len(msg))
            Logger.error("The following command failed (exit code: {}): {}".format(error.returncode, " ".join(error.cmd)))
            for l in error.stderr.decode('utf-8').split('\n'):
                if (len(l) > 0):
                    Logger.info("STDERR: {}".format(l))
        except Exception as e:
            Logger.reset_line(pad=len(msg))
            Logger.error("Failed to configure samba: '{}'.".format(e))

    def install_all(self) -> None:
        self.__update_system()
        self.__install_all_packages(PackageType.APT)
        self.__install_all_packages(PackageType.PYTHON)
        self.__install_all_packages(PackageType.RUBY)
        self.__install_all_packages(PackageType.BINARY)
        self.__install_all_packages(PackageType.GIT)
        self.__install_all_packages(PackageType.GIT_RELEASE)
        self.__configure_symlinks()
        self.__configure_aliases()
        self.__configure_terminator()
        self.__configure_vim()
        self.__configure_metasploit()
        self.__configure_samba()
        self.__configure_desktop_environment()
        self.__save_config_file_as_current()

    def update_all(self) -> None:
        self.__update_system()
        self.__cleanup_system()
        self.__update_all_packages(PackageType.APT)
        self.__update_all_packages(PackageType.PYTHON)
        self.__update_all_packages(PackageType.RUBY)
        self.__update_all_packages(PackageType.BINARY)
        self.__update_all_packages(PackageType.GIT)
        self.__update_all_packages(PackageType.GIT_RELEASE)
        self.__remove_all()
        self.__configure_symlinks()
        self.__configure_aliases()
        self.__update_locate_db()
        self.__save_config_file_as_current()
